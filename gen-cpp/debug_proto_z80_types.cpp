/**
 * Autogenerated by Thrift Compiler (0.14.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "debug_proto_z80_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kGpRegsEnumValues[] = {
  GpRegsEnum::AF,
  GpRegsEnum::AF2,
  GpRegsEnum::BC,
  GpRegsEnum::BC2,
  GpRegsEnum::DE,
  GpRegsEnum::DE2,
  GpRegsEnum::HL,
  GpRegsEnum::HL2,
  GpRegsEnum::IX,
  GpRegsEnum::IY,
  GpRegsEnum::I,
  GpRegsEnum::R,
  GpRegsEnum::PC,
  GpRegsEnum::SP,
  GpRegsEnum::IP,
  GpRegsEnum::BANK
};
const char* _kGpRegsEnumNames[] = {
  "AF",
  "AF2",
  "BC",
  "BC2",
  "DE",
  "DE2",
  "HL",
  "HL2",
  "IX",
  "IY",
  "I",
  "R",
  "PC",
  "SP",
  "IP",
  "BANK"
};
const std::map<int, const char*> _GpRegsEnum_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(16, _kGpRegsEnumValues, _kGpRegsEnumNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const GpRegsEnum::type& val) {
  std::map<int, const char*>::const_iterator it = _GpRegsEnum_VALUES_TO_NAMES.find(val);
  if (it != _GpRegsEnum_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const GpRegsEnum::type& val) {
  std::map<int, const char*>::const_iterator it = _GpRegsEnum_VALUES_TO_NAMES.find(val);
  if (it != _GpRegsEnum_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kBpTypeValues[] = {
  BpType::BP_PC,
  BpType::BP_READ,
  BpType::BP_WRITE
};
const char* _kBpTypeNames[] = {
  "BP_PC",
  "BP_READ",
  "BP_WRITE"
};
const std::map<int, const char*> _BpType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kBpTypeValues, _kBpTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const BpType::type& val) {
  std::map<int, const char*>::const_iterator it = _BpType_VALUES_TO_NAMES.find(val);
  if (it != _BpType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const BpType::type& val) {
  std::map<int, const char*>::const_iterator it = _BpType_VALUES_TO_NAMES.find(val);
  if (it != _BpType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


GpRegister::~GpRegister() noexcept {
}


void GpRegister::__set_index(const GpRegsEnum::type val) {
  this->index = val;
}

void GpRegister::__set_value(const int32_t val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const GpRegister& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GpRegister::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->index = (GpRegsEnum::type)ecast0;
          this->__isset.index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GpRegister::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GpRegister");

  xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GpRegister &a, GpRegister &b) {
  using ::std::swap;
  swap(a.index, b.index);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

GpRegister::GpRegister(const GpRegister& other1) {
  index = other1.index;
  value = other1.value;
  __isset = other1.__isset;
}
GpRegister& GpRegister::operator=(const GpRegister& other2) {
  index = other2.index;
  value = other2.value;
  __isset = other2.__isset;
  return *this;
}
void GpRegister::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GpRegister(";
  out << "index=" << to_string(index);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


GpRegisters::~GpRegisters() noexcept {
}


void GpRegisters::__set_AF(const int32_t val) {
  this->AF = val;
}

void GpRegisters::__set_AF2(const int32_t val) {
  this->AF2 = val;
}

void GpRegisters::__set_BC(const int32_t val) {
  this->BC = val;
}

void GpRegisters::__set_BC2(const int32_t val) {
  this->BC2 = val;
}

void GpRegisters::__set_DE(const int32_t val) {
  this->DE = val;
}

void GpRegisters::__set_DE2(const int32_t val) {
  this->DE2 = val;
}

void GpRegisters::__set_HL(const int32_t val) {
  this->HL = val;
}

void GpRegisters::__set_HL2(const int32_t val) {
  this->HL2 = val;
}

void GpRegisters::__set_IX(const int32_t val) {
  this->IX = val;
}

void GpRegisters::__set_IY(const int32_t val) {
  this->IY = val;
}

void GpRegisters::__set_I(const int32_t val) {
  this->I = val;
}

void GpRegisters::__set_R(const int32_t val) {
  this->R = val;
}

void GpRegisters::__set_SP(const int32_t val) {
  this->SP = val;
}

void GpRegisters::__set_PC(const int32_t val) {
  this->PC = val;
}

void GpRegisters::__set_IP(const int32_t val) {
  this->IP = val;
}

void GpRegisters::__set_BANK(const int32_t val) {
  this->BANK = val;
}
std::ostream& operator<<(std::ostream& out, const GpRegisters& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GpRegisters::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->AF);
          this->__isset.AF = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->AF2);
          this->__isset.AF2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->BC);
          this->__isset.BC = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->BC2);
          this->__isset.BC2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->DE);
          this->__isset.DE = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->DE2);
          this->__isset.DE2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->HL);
          this->__isset.HL = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->HL2);
          this->__isset.HL2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->IX);
          this->__isset.IX = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->IY);
          this->__isset.IY = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->I);
          this->__isset.I = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->R);
          this->__isset.R = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->SP);
          this->__isset.SP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->PC);
          this->__isset.PC = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->IP);
          this->__isset.IP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->BANK);
          this->__isset.BANK = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GpRegisters::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GpRegisters");

  xfer += oprot->writeFieldBegin("AF", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->AF);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("AF2", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->AF2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("BC", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->BC);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("BC2", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->BC2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("DE", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->DE);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("DE2", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->DE2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("HL", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->HL);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("HL2", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->HL2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("IX", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->IX);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("IY", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->IY);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("I", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->I);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("R", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(this->R);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("SP", ::apache::thrift::protocol::T_I32, 13);
  xfer += oprot->writeI32(this->SP);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("PC", ::apache::thrift::protocol::T_I32, 14);
  xfer += oprot->writeI32(this->PC);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("IP", ::apache::thrift::protocol::T_I32, 15);
  xfer += oprot->writeI32(this->IP);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("BANK", ::apache::thrift::protocol::T_I32, 16);
  xfer += oprot->writeI32(this->BANK);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GpRegisters &a, GpRegisters &b) {
  using ::std::swap;
  swap(a.AF, b.AF);
  swap(a.AF2, b.AF2);
  swap(a.BC, b.BC);
  swap(a.BC2, b.BC2);
  swap(a.DE, b.DE);
  swap(a.DE2, b.DE2);
  swap(a.HL, b.HL);
  swap(a.HL2, b.HL2);
  swap(a.IX, b.IX);
  swap(a.IY, b.IY);
  swap(a.I, b.I);
  swap(a.R, b.R);
  swap(a.SP, b.SP);
  swap(a.PC, b.PC);
  swap(a.IP, b.IP);
  swap(a.BANK, b.BANK);
  swap(a.__isset, b.__isset);
}

GpRegisters::GpRegisters(const GpRegisters& other3) {
  AF = other3.AF;
  AF2 = other3.AF2;
  BC = other3.BC;
  BC2 = other3.BC2;
  DE = other3.DE;
  DE2 = other3.DE2;
  HL = other3.HL;
  HL2 = other3.HL2;
  IX = other3.IX;
  IY = other3.IY;
  I = other3.I;
  R = other3.R;
  SP = other3.SP;
  PC = other3.PC;
  IP = other3.IP;
  BANK = other3.BANK;
  __isset = other3.__isset;
}
GpRegisters& GpRegisters::operator=(const GpRegisters& other4) {
  AF = other4.AF;
  AF2 = other4.AF2;
  BC = other4.BC;
  BC2 = other4.BC2;
  DE = other4.DE;
  DE2 = other4.DE2;
  HL = other4.HL;
  HL2 = other4.HL2;
  IX = other4.IX;
  IY = other4.IY;
  I = other4.I;
  R = other4.R;
  SP = other4.SP;
  PC = other4.PC;
  IP = other4.IP;
  BANK = other4.BANK;
  __isset = other4.__isset;
  return *this;
}
void GpRegisters::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GpRegisters(";
  out << "AF=" << to_string(AF);
  out << ", " << "AF2=" << to_string(AF2);
  out << ", " << "BC=" << to_string(BC);
  out << ", " << "BC2=" << to_string(BC2);
  out << ", " << "DE=" << to_string(DE);
  out << ", " << "DE2=" << to_string(DE2);
  out << ", " << "HL=" << to_string(HL);
  out << ", " << "HL2=" << to_string(HL2);
  out << ", " << "IX=" << to_string(IX);
  out << ", " << "IY=" << to_string(IY);
  out << ", " << "I=" << to_string(I);
  out << ", " << "R=" << to_string(R);
  out << ", " << "SP=" << to_string(SP);
  out << ", " << "PC=" << to_string(PC);
  out << ", " << "IP=" << to_string(IP);
  out << ", " << "BANK=" << to_string(BANK);
  out << ")";
}


DbgBreakpoint::~DbgBreakpoint() noexcept {
}


void DbgBreakpoint::__set_type(const BpType::type val) {
  this->type = val;
}

void DbgBreakpoint::__set_bstart(const int32_t val) {
  this->bstart = val;
}

void DbgBreakpoint::__set_bend(const int32_t val) {
  this->bend = val;
}

void DbgBreakpoint::__set_enabled(const bool val) {
  this->enabled = val;
}

void DbgBreakpoint::__set_is_forbid(const bool val) {
  this->is_forbid = val;
}
std::ostream& operator<<(std::ostream& out, const DbgBreakpoint& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DbgBreakpoint::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast5;
          xfer += iprot->readI32(ecast5);
          this->type = (BpType::type)ecast5;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bstart);
          this->__isset.bstart = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bend);
          this->__isset.bend = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enabled);
          this->__isset.enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_forbid);
          this->__isset.is_forbid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DbgBreakpoint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DbgBreakpoint");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bstart", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->bstart);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bend", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->bend);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enabled", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->enabled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_forbid", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->is_forbid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DbgBreakpoint &a, DbgBreakpoint &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.bstart, b.bstart);
  swap(a.bend, b.bend);
  swap(a.enabled, b.enabled);
  swap(a.is_forbid, b.is_forbid);
  swap(a.__isset, b.__isset);
}

DbgBreakpoint::DbgBreakpoint(const DbgBreakpoint& other6) {
  type = other6.type;
  bstart = other6.bstart;
  bend = other6.bend;
  enabled = other6.enabled;
  is_forbid = other6.is_forbid;
  __isset = other6.__isset;
}
DbgBreakpoint& DbgBreakpoint::operator=(const DbgBreakpoint& other7) {
  type = other7.type;
  bstart = other7.bstart;
  bend = other7.bend;
  enabled = other7.enabled;
  is_forbid = other7.is_forbid;
  __isset = other7.__isset;
  return *this;
}
void DbgBreakpoint::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DbgBreakpoint(";
  out << "type=" << to_string(type);
  out << ", " << "bstart=" << to_string(bstart);
  out << ", " << "bend=" << to_string(bend);
  out << ", " << "enabled=" << to_string(enabled);
  out << ", " << "is_forbid=" << to_string(is_forbid);
  out << ")";
}


